{
  "master": {
    "tasks": [
      {
        "id": "36",
        "title": "Repository File Cleanup",
        "description": "Clean up project root directory by removing development artifacts, test files, SQL migration files, and documentation duplicates while preserving essential project files",
        "details": "Remove SQL files (check_*.sql, enable_rls_*.sql, fix_*.sql, FINAL_SETUP_*.sql, KROK_*.sql, supabase_trigger_*.sql), test files (test-*.ts, test-*.js, test-*.mjs, test-*.xlsx, test-*.csv, check-*.js, verify-*.md), documentation duplicates (files ending with ' 2.md', ' 2.sql', ' 2.json'), old reports (EXCEL-*.md, INPRO-*.md, MINISTRY_XML_*.md, etc.), IDE configs (opencode*.json, claude_desktop_config*.json), CSV exports (ceny-mieszkan-*.csv), and backup folders. Keep essential files: .taskmaster/, .coderabbit-analysis/, src/, package.json, next.config.ts, tsconfig.json, CLAUDE.md, README.md, .env* files. Use bash commands to remove files systematically and create git commit with list of removed files.",
        "testStrategy": "Verify root directory contains only essential files, confirm no test/debug files remain in root, ensure application still builds and runs correctly after cleanup, create git commit documenting removed files",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create a Script to Identify and List Unwanted Files",
            "description": "Develop a bash script that uses `find` commands to locate all files matching the specified patterns for deletion. The script should output a comprehensive list of these files to a temporary file (e.g., `files_to_remove.txt`) for review and for use in the final git commit message, without performing any deletion.",
            "dependencies": [],
            "details": "The script should use patterns like `check_*.sql`, `test-*.ts`, `* 2.md`, `opencode*.json`, `ceny-mieszkan-*.csv`, etc., as specified in the parent task. It should search the project root directory and be configured to avoid traversing into essential directories like `src/` or `.taskmaster/`. The output file will serve as a manifest for the cleanup operation.",
            "status": "pending",
            "testStrategy": "Run the script and manually review the generated `files_to_remove.txt` to ensure it correctly identifies only the intended files for deletion and does not list any essential project files like `package.json` or files within `src/`.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Script the Removal of Development and Test Artifacts",
            "description": "Create a bash script that removes specific development and testing artifacts from the project root. This includes temporary SQL files, various test files, and IDE-specific configuration files.",
            "dependencies": [
              "36.1"
            ],
            "details": "The script will use `rm` commands with patterns identified in the previous step, such as `check_*.sql`, `enable_rls_*.sql`, `fix_*.sql`, `FINAL_SETUP_*.sql`, `KROK_*.sql`, `supabase_trigger_*.sql`, `test-*.{ts,js,mjs,xlsx,csv}`, `check-*.js`, `verify-*.md`, `opencode*.json`, and `claude_desktop_config*.json`. The script should be designed to be run from the project root.",
            "status": "pending",
            "testStrategy": "On a separate test branch, run the script and verify using `ls -a` and `git status` that the targeted files have been removed and no other files were affected.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Script the Removal of Duplicates, Reports, and Data Exports",
            "description": "Create a bash script to clean up outdated and redundant files, specifically documentation duplicates, old markdown reports, temporary CSV data exports, and specified backup folders.",
            "dependencies": [
              "36.1"
            ],
            "details": "The script will use `rm` commands with patterns like `* 2.{md,sql,json}`, `EXCEL-*.md`, `INPRO-*.md`, `MINISTRY_XML_*.md`, and `ceny-mieszkan-*.csv`. It should also include commands to remove any specified backup folders using `rm -rf`.",
            "status": "pending",
            "testStrategy": "On a separate test branch, run the script and confirm that only the specified duplicate files, reports, CSVs, and backup folders are deleted. Check that essential files remain untouched.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Execute Cleanup and Perform Project Integrity Verification",
            "description": "Run the created cleanup scripts to remove all identified files. After the cleanup, verify that the application remains functional by running the build process and starting the development server.",
            "dependencies": [
              "36.2",
              "36.3"
            ],
            "details": "Sequentially execute the removal scripts from subtasks 2 and 3. After execution, run `npm run build` to ensure the project compiles without TypeScript errors. Start the application locally to confirm it runs without runtime errors, ensuring no critical files were accidentally deleted.",
            "status": "pending",
            "testStrategy": "The `npm run build` command must complete successfully. The application must start, and the main pages must render correctly in a browser without console errors. A `git status` should show only deletions of the targeted files.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create Final Git Commit with a Detailed List of Removed Files",
            "description": "Stage all the file deletions and create a single, well-documented git commit. The commit message must include a comprehensive list of all files that were removed during the cleanup process.",
            "dependencies": [
              "36.4"
            ],
            "details": "Use `git add -u` to stage all the deletions. Construct a commit message that clearly states the purpose of the cleanup (e.g., 'chore: Clean up project root from development artifacts'). Append the contents of the `files_to_remove.txt` file (generated in subtask 1) to the commit message body to provide a precise record of the changes.",
            "status": "pending",
            "testStrategy": "Review the git commit history using `git log -1 --stat` to confirm the commit message is accurate and contains the full list of removed files. Verify that the remote repository reflects the changes correctly after pushing.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-07T16:03:50.351Z"
      },
      {
        "id": "37",
        "title": "Fix XML Auto-Refresh for Ministry Compliance",
        "description": "Update XML and MD5 endpoints to disable caching and ensure daily date updates for Ministry Art. 19b compliance requirements",
        "details": "Modify src/app/api/public/[clientId]/data.xml/route.ts: change 'export const revalidate = 300' to 'export const revalidate = 0', update Cache-Control header from 'max-age=300' to 'max-age=60'. Apply same changes to src/app/api/public/[clientId]/data.md5/route.ts. This ensures XML returns current date in YYYY-MM-DD format for ministry compliance while maintaining 1-minute client cache.",
        "testStrategy": "Test XML endpoint returns current date on each request, verify MD5 checksum matches fresh XML content, confirm multiple requests within 1 minute return cached response, verify requests after 1 minute return fresh content with new date",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Update Caching Configuration for XML Endpoint",
            "description": "Modify the data.xml route to disable server-side caching and set the client-side cache duration to 60 seconds for ministry compliance.",
            "dependencies": [],
            "details": "In 'src/app/api/public/[clientId]/data.xml/route.ts', change 'export const revalidate = 300' to 'export const revalidate = 0' and update the Cache-Control header from 'max-age=300' to 'max-age=60'.",
            "status": "pending",
            "testStrategy": "Code review to confirm the revalidate and Cache-Control values are correctly updated in the specified file.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Update Caching Configuration for MD5 Endpoint",
            "description": "Apply the same caching modifications to the data.md5 route, disabling server-side caching and setting the client-side cache to 60 seconds to maintain consistency with the XML endpoint.",
            "dependencies": [],
            "details": "In 'src/app/api/public/[clientId]/data.md5/route.ts', change 'export const revalidate = 300' to 'export const revalidate = 0' and update the Cache-Control header from 'max-age=300' to 'max-age=60'.",
            "status": "pending",
            "testStrategy": "Code review to confirm the revalidate and Cache-Control values are correctly updated in the specified file.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Verify Server-Side Refresh and Current Date",
            "description": "Test the data.xml endpoint to confirm that server-side caching is disabled and that it returns the current date in YYYY-MM-DD format on new server requests after the client cache expires.",
            "dependencies": [
              "37.1"
            ],
            "details": "Use a tool like curl to make a request to the data.xml endpoint. Wait for more than 60 seconds and make another request. Verify the server is hit again (e.g., no X-Vercel-Cache: HIT) and the <data_aggiornamento> tag contains the current date.",
            "status": "pending",
            "testStrategy": "Execute two requests to the XML endpoint spaced more than 60 seconds apart. The test passes if the date in the second response is current and the response is not a cache hit.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Validate 60-Second Client-Side Caching Behavior",
            "description": "Confirm that both the XML and MD5 endpoints are correctly cached by the client for 60 seconds as specified by the updated 'Cache-Control: max-age=60' header.",
            "dependencies": [
              "37.1",
              "37.2"
            ],
            "details": "Using a browser's network tab or curl, make a request to data.xml. Immediately make a second request within the 60-second window. Verify the second response is served from a cache. Repeat the process for the data.md5 endpoint.",
            "status": "pending",
            "testStrategy": "The test is successful if subsequent requests within 60 seconds are served from a cache (e.g., browser cache or CDN HIT) and do not trigger a new server-side execution.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Perform MD5 Integrity Check",
            "description": "Verify that the checksum from the data.md5 endpoint correctly corresponds to the content of a freshly generated data.xml file, ensuring data integrity for compliance.",
            "dependencies": [
              "37.3",
              "37.4"
            ],
            "details": "After ensuring the cache has expired (>60s), fetch the content from the data.xml endpoint. Calculate its MD5 checksum. Then, fetch the value from the data.md5 endpoint. Verify that the calculated checksum matches the fetched checksum.",
            "status": "pending",
            "testStrategy": "The test passes if the locally calculated MD5 hash of the XML content exactly matches the string returned by the MD5 endpoint for non-cached responses.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-07T16:07:38.630Z"
      },
      {
        "id": "38",
        "title": "Remove Unused Dashboard Components",
        "description": "Simplify dashboard layout by removing SubscriptionCard and SubscriptionErrorHandler components that are not needed for v2",
        "details": "Edit src/app/dashboard/page.tsx: remove import statements for SubscriptionCard and SubscriptionErrorHandler, remove <SubscriptionErrorHandler /> and <SubscriptionCard /> components from JSX. Keep only UploadWidget, ActionButtons, and PropertiesTable components in the dashboard layout. Ensure TypeScript compilation passes and no runtime errors occur.",
        "testStrategy": "Verify dashboard renders with simplified layout containing only UploadWidget, ActionButtons, and PropertiesTable. Confirm no TypeScript errors during compilation and no runtime errors in browser console",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Locate Unused Component Code in Dashboard File",
            "description": "Identify the exact import statements and JSX element usages for SubscriptionCard and SubscriptionErrorHandler within the src/app/dashboard/page.tsx file.",
            "dependencies": [],
            "details": "Open src/app/dashboard/page.tsx and find the lines corresponding to `import SubscriptionCard...`, `import SubscriptionErrorHandler...`, `<SubscriptionCard />`, and `<SubscriptionErrorHandler />`. Document the line numbers for removal in the subsequent steps.",
            "status": "pending",
            "testStrategy": "Confirm that the identified lines are the only references to SubscriptionCard and SubscriptionErrorHandler in the file.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Remove Unused Import Statements",
            "description": "Delete the import statements for SubscriptionCard and SubscriptionErrorHandler from the top of src/app/dashboard/page.tsx.",
            "dependencies": [
              "38.1"
            ],
            "details": "Edit src/app/dashboard/page.tsx and remove the two lines that import the SubscriptionCard and SubscriptionErrorHandler components. Save the file.",
            "status": "pending",
            "testStrategy": "Review the file changes to ensure only the specified import statements have been deleted.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Remove Unused JSX Components from Layout",
            "description": "Delete the <SubscriptionCard /> and <SubscriptionErrorHandler /> component elements from the JSX returned by the Dashboard page component.",
            "dependencies": [
              "38.1"
            ],
            "details": "In src/app/dashboard/page.tsx, locate and remove the <SubscriptionErrorHandler /> and <SubscriptionCard /> tags from the component's render method. Ensure the remaining components (UploadWidget, ActionButtons, PropertiesTable) are still present and the layout is syntactically correct.",
            "status": "pending",
            "testStrategy": "Visually inspect the JSX code to confirm the components have been removed and the remaining layout structure is valid.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Verify TypeScript Compilation Success",
            "description": "Run the project's build process to confirm that the code changes do not introduce any TypeScript compilation errors.",
            "dependencies": [
              "38.2",
              "38.3"
            ],
            "details": "Execute the command for type-checking and building the project (e.g., `npm run build` or `tsc`). The process must complete without any new errors related to the dashboard page or missing components.",
            "status": "pending",
            "testStrategy": "Confirm that the build command finishes with a success status (exit code 0) and no TypeScript errors are logged in the console.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Perform Runtime and Visual Validation",
            "description": "Run the application, navigate to the dashboard, and verify the simplified layout renders correctly without any client-side errors.",
            "dependencies": [
              "38.4"
            ],
            "details": "Start the development server. Open the application in a browser and go to the dashboard page. Check that the SubscriptionCard and SubscriptionErrorHandler are no longer visible. Confirm that UploadWidget, ActionButtons, and PropertiesTable are displayed correctly. Open the browser's developer console and ensure no new runtime errors or warnings are present.",
            "status": "pending",
            "testStrategy": "The dashboard UI renders with the simplified layout. The browser's console shows no errors upon page load or interaction.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-07T16:24:26.176Z"
      },
      {
        "id": "39",
        "title": "Implement Property Status Management System",
        "description": "Add property status management functionality allowing developers to mark properties as sold/unavailable with UI controls and API endpoints",
        "details": "Create database enum for property status (available, sold, reserved). Add status column to properties table with RLS policies. Create API endpoints: PATCH /api/properties/[id] for single property updates and PATCH /api/properties/bulk for bulk updates. Build UI components: StatusBadge (green=available, red=sold, yellow=reserved), StatusSelect dropdown using Radix UI Select, BulkActions toolbar using Radix UI Toolbar. Add 'Mark as Sold' buttons in PropertiesTable, implement bulk selection with checkboxes. Filter sold properties from Ministry XML/CSV exports. Include loading states, error handling with toast notifications using Sonner.",
        "testStrategy": "Test status changes persist in database, verify sold properties excluded from ministry endpoints, test bulk update functionality with multiple selected properties, confirm loading states and error handling work correctly, validate RLS policies prevent unauthorized updates",
        "priority": "high",
        "dependencies": [
          "38"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Database Schema Update for Property Status",
            "description": "Modify the database to support property statuses by creating a new enum type and adding a status column to the properties table, including necessary security policies.",
            "dependencies": [],
            "details": "Create a new `property_status` enum type in the database with values: 'available', 'sold', 'reserved'. Add a 'status' column to the 'properties' table, using the new enum type and setting a default value of 'available'. Implement Row-Level Security (RLS) policies to ensure only the property's owner (developer) can update the status.",
            "status": "pending",
            "testStrategy": "Verify the 'status' column exists in the 'properties' table with the correct enum type and default value. Test RLS policies by attempting to update a property's status with an unauthorized user account, expecting failure.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create API Endpoints for Status Updates",
            "description": "Develop API routes for updating the status of single and multiple properties, ensuring proper authorization and input validation.",
            "dependencies": [
              "39.1"
            ],
            "details": "Implement a `PATCH /api/properties/[id]` endpoint to update the status of a single property. Implement a `PATCH /api/properties/bulk` endpoint that accepts an array of property IDs and a new status to update them in a single transaction. Ensure both endpoints validate user authorization against RLS policies and handle input correctly.",
            "status": "pending",
            "testStrategy": "Test the PATCH /api/properties/[id] endpoint by updating a single property's status and verifying the change in the database. Test the PATCH /api/properties/bulk endpoint with multiple property IDs and confirm all are updated correctly. Test for proper error handling with invalid input.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Build Reusable Status UI Components",
            "description": "Create the fundamental, reusable UI components for displaying and interacting with property statuses using Radix UI.",
            "dependencies": [],
            "details": "Build a `StatusBadge` component that displays a colored badge based on the property status (green for 'available', red for 'sold', yellow for 'reserved'). Create a `StatusSelect` dropdown component using Radix UI Select for choosing a status. Develop a `BulkActions` toolbar component using Radix UI Toolbar to house actions for selected properties.",
            "status": "pending",
            "testStrategy": "Visually verify the StatusBadge component displays the correct color for each status. Test the StatusSelect dropdown renders all status options. Use Storybook or a similar tool to test components in isolation.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integrate Status Management into Properties Table",
            "description": "Enhance the properties table with status selection, bulk actions, and user feedback mechanisms like loading states and notifications.",
            "dependencies": [
              "39.2",
              "39.3"
            ],
            "details": "Modify the `PropertiesTable` to include a checkbox for each row to enable bulk selection. Integrate the `BulkActions` toolbar, which appears when properties are selected. Add the `StatusSelect` dropdown or a 'Mark as Sold' button to each row for individual updates. Implement loading states for API calls and use Sonner for toast notifications on success or error.",
            "status": "pending",
            "testStrategy": "Confirm that selecting properties via checkboxes reveals the BulkActions toolbar. Test bulk update functionality from the UI. Test individual status updates. Verify that loading states are shown during API calls and that success/error toast notifications appear correctly.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Filter Exports Based on Property Status",
            "description": "Exclude sold properties from ministry-facing XML and CSV data exports to ensure compliance and data accuracy.",
            "dependencies": [
              "39.1"
            ],
            "details": "Modify the logic for generating the Ministry XML and any related CSV exports. Update the database queries or data filtering process to exclude properties with a 'sold' status. Ensure that only properties marked as 'available' or 'reserved' are included in the final export files.",
            "status": "pending",
            "testStrategy": "Generate the Ministry XML and CSV exports after marking several properties as 'sold'. Verify that the sold properties are correctly excluded from the generated files. Confirm that 'available' and 'reserved' properties are still included.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-07T17:21:11.166Z"
      },
      {
        "id": "40",
        "title": "Enhance Settings Page with Complete User Management",
        "description": "Expand the existing settings page to include profile management, API configuration, notification preferences, and account actions",
        "details": "Enhance src/app/dashboard/settings/page.tsx with four sections: 1) Profile Settings - company name, NIP, REGON, email, phone with form validation, 2) API Configuration - display client_id (read-only), regenerate client_id button with confirmation dialog, ministry endpoint URLs with copy buttons, 3) Notification Preferences - email notifications toggle, frequency selection (daily/weekly), 4) Account Actions - change password, delete account with confirmation. Create API endpoints: GET /api/user/profile, PATCH /api/user/profile, POST /api/user/regenerate-client-id. Use Radix UI components for forms, dialogs, and switches. Implement form validation with Zod schemas.",
        "testStrategy": "Test form validation for required fields and formats, verify profile updates persist in database, test client_id regeneration creates new UUID, confirm success/error toast notifications display correctly, validate all API endpoints work properly",
        "priority": "medium",
        "dependencies": [],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Create API Endpoints for User Profile Management",
            "description": "Implement the backend API routes required to fetch and update user profile information, which will serve as the data layer for the settings page.",
            "dependencies": [],
            "details": "Create the API route `GET /api/user/profile` to retrieve the current user's data, including company name, NIP, REGON, email, phone, and client_id. Create the API route `PATCH /api/user/profile` to update the user's profile information, ensuring server-side validation of the incoming data.",
            "status": "pending",
            "testStrategy": "Verify that GET /api/user/profile returns the correct user data. Test PATCH /api/user/profile with valid and invalid data to ensure updates are successful and validation errors are returned correctly.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Profile Settings Form UI",
            "description": "Build the 'Profile Settings' section on the settings page, allowing users to view and edit their profile information with client-side validation.",
            "dependencies": [
              "40.1"
            ],
            "details": "In `src/app/dashboard/settings/page.tsx`, create a form using Radix UI components for company name, NIP, REGON, email, and phone. Implement client-side validation using a Zod schema. Connect the form to the GET and PATCH API endpoints to fetch initial data and submit updates. Implement loading and disabled states during form submission.",
            "status": "pending",
            "testStrategy": "Test form validation for all fields (required, format). Verify that submitting the form successfully calls the PATCH API and updates the UI. Confirm that data from the GET API correctly populates the form on initial load.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Develop API Configuration Section with Client ID Regeneration",
            "description": "Create the 'API Configuration' section, including the backend logic and UI for displaying API details and regenerating the client ID.",
            "dependencies": [
              "40.1"
            ],
            "details": "Implement the `POST /api/user/regenerate-client-id` endpoint to generate a new UUID for the user's client_id. In the UI, display the read-only client_id fetched from the profile API. Add a 'Regenerate' button that triggers a Radix UI confirmation dialog before calling the API. Display the static ministry endpoint URLs with 'Copy to Clipboard' buttons.",
            "status": "pending",
            "testStrategy": "Verify the client_id is displayed correctly. Test the 'Regenerate' button, confirm the dialog appears, and a new UUID is generated and persisted upon confirmation. Test the 'Copy' buttons to ensure they copy the correct URLs to the clipboard.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Build UI for Notification Preferences and Account Actions",
            "description": "Construct the user interface for the 'Notification Preferences' and 'Account Actions' sections using Radix UI components for user interaction.",
            "dependencies": [],
            "details": "In the 'Notification Preferences' section, add a Radix UI Switch for enabling/disabling email notifications and a Radix UI Select for choosing frequency (daily/weekly). In the 'Account Actions' section, add buttons for 'Change Password' and 'Delete Account', with each button configured to trigger a respective Radix UI confirmation dialog. This subtask focuses on UI structure and component implementation.",
            "status": "pending",
            "testStrategy": "Confirm all UI components (Switch, Select, Buttons, Dialogs) render correctly. Verify that interacting with the components (e.g., opening a dialog) works as expected.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Backend for Account Actions and Final Integration",
            "description": "Create the necessary API endpoints for account actions and notification preferences, and integrate all four sections into a cohesive settings page with user feedback.",
            "dependencies": [
              "40.2",
              "40.3",
              "40.4"
            ],
            "details": "Create API endpoints to handle changing passwords and deleting user accounts. Implement the backend logic to update notification preferences in the database. Connect the UI components from subtask 4 to these new endpoints. Implement success and error toast notifications for all actions on the page (profile update, ID regeneration, password change, etc.) to provide clear user feedback.",
            "status": "pending",
            "testStrategy": "Test the API endpoints for changing password, deleting account, and updating notification preferences. Verify that the UI correctly calls these endpoints. Confirm that success/error toast notifications are displayed appropriately for every user action on the settings page.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-07T17:56:28.521Z"
      },
      {
        "id": "41",
        "title": "Create Notifications System and Page",
        "description": "Implement a comprehensive notifications system with database table, API endpoints, and /notifications page UI",
        "details": "Create notifications table in Supabase with columns: id, developer_id, type (upload_complete, upload_error, ministry_sync, system_announcement), title, message, read (boolean), created_at. Implement RLS policies for developer-only access. Create API endpoints: GET /api/notifications (list with pagination), PATCH /api/notifications/[id] (mark as read), DELETE /api/notifications/[id] (delete). Build /notifications page showing list sorted by newest first, with mark as read/unread buttons, delete functionality, and empty state. Add unread count badge in header that updates real-time. Use existing Radix UI components for consistent styling.",
        "testStrategy": "Test notifications page renders correctly, verify mark as read/unread functionality, confirm delete operations work, test unread count badge updates correctly, validate RLS policies prevent unauthorized access, test empty state display",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "42",
        "title": "Add Dashboard Statistics Cards",
        "description": "Create overview statistics cards displaying key metrics on the dashboard top section",
        "details": "Create statistics cards component showing: total properties, available properties, sold properties (this month), average price per m². Design 4-card grid layout (2x2 on mobile, 4x1 on desktop) with icons from Lucide React, values, labels, and trend indicators (↑/↓ compared to last month). Create API endpoint GET /api/dashboard/stats returning aggregated statistics from properties table. Position cards above UploadWidget in dashboard layout. Include loading skeleton states and error handling. Use date-fns for date calculations and filtering.",
        "testStrategy": "Verify stats cards render above upload widget, test data refreshes on page load, confirm loading skeleton displays during fetch, validate error states handled gracefully, test responsive layout on mobile and desktop",
        "priority": "low",
        "dependencies": [
          "39"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Statistics API Endpoint",
            "description": "Implement GET /api/dashboard/stats endpoint that aggregates property statistics from the database",
            "dependencies": [],
            "details": "Create route at src/app/api/dashboard/stats/route.ts that queries the properties table to calculate: total properties count, available properties count (status = 'available'), sold properties count for current month (status = 'sold' + date filtering), and average price per m2. Use date-fns for current month filtering with proper timezone handling. Include previous month calculations for trend comparison. Implement proper error handling, authentication via Supabase auth, and RLS policy enforcement. Return JSON response with statistics and trend indicators.",
            "status": "pending",
            "testStrategy": "Test endpoint returns correct aggregated data, verify authentication required, confirm RLS policies work, test with empty database, validate date filtering logic",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create Statistics Cards Component",
            "description": "Build reusable StatsCard component and StatisticsCards container component for displaying dashboard metrics",
            "dependencies": [],
            "details": "Create components/dashboard/statistics-cards.tsx with individual StatsCard component using existing Card UI components from src/components/ui/card.tsx. Include props for title, value, icon (from lucide-react), trend direction and percentage. Create StatisticsCards container component that fetches data from /api/dashboard/stats endpoint using SWR for caching. Implement responsive grid layout (2x2 on mobile, 4x1 on desktop) using CSS Grid and Tailwind classes. Add loading skeleton states using existing LoadingState pattern and error handling with proper error display.",
            "status": "pending",
            "testStrategy": "Test component renders correctly with mock data, verify responsive layout on different screen sizes, confirm loading states display properly, test error handling scenarios",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add Icons and Trend Indicators",
            "description": "Implement icon selection and trend indicator logic for each statistics card",
            "dependencies": [
              "42.2"
            ],
            "details": "Add lucide-react icons to StatsCard component: Building2 for total properties, Home for available properties, HandCoins for sold properties, Calculator for average price per m2. Implement trend indicator with up/down arrows (ChevronUp, ChevronDown) and percentage change display. Add conditional styling for positive (green) and negative (red) trends. Ensure icons are accessible with proper aria-labels and maintain consistent sizing across all cards.",
            "status": "pending",
            "testStrategy": "Verify correct icons display for each metric, test trend indicators show proper colors and arrows, confirm accessibility attributes are present",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integrate Statistics Cards into Dashboard Layout",
            "description": "Add StatisticsCards component to dashboard page above the UploadWidget component",
            "dependencies": [
              "42.2"
            ],
            "details": "Edit src/app/dashboard/page.tsx to import and add StatisticsCards component in the dashboard grid section, positioned before the UploadWidget component. Ensure proper spacing using existing space-y-6 pattern. Add Suspense wrapper with appropriate loading fallback to match existing lazy-loaded components pattern. Maintain existing dashboard structure and styling consistency.",
            "status": "pending",
            "testStrategy": "Verify statistics cards appear above upload widget, confirm proper spacing and layout integration, test loading states work correctly with Suspense",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add Data Fetching and Error Handling",
            "description": "Implement SWR-based data fetching with proper error handling and loading states",
            "dependencies": [
              "42.1",
              "42.2"
            ],
            "details": "Add SWR hook in StatisticsCards component to fetch data from /api/dashboard/stats with automatic revalidation on page focus. Implement error boundary integration and fallback states for network errors. Add retry logic and loading skeletons that match existing component patterns. Use existing error display components and ensure consistent error messaging. Include data refresh on property updates using SWR mutate functionality.",
            "status": "pending",
            "testStrategy": "Test data loads correctly on component mount, verify error states display properly, confirm retry functionality works, test loading skeleton appears during fetch",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "43",
        "title": "Implement Email Notification System",
        "description": "Set up automated email notifications for important events using Resend API with React Email templates",
        "details": "Create email notification system using existing Resend dependency and @react-email/render. Build email templates: upload completed (with summary), upload failed (with error details), weekly report (every Monday with stats). Implement notification triggers in upload API routes and create weekly cron job using Vercel Cron API routes. Create email templates directory with React Email components ensuring mobile-responsive design. Add opt-out functionality in settings page. Log failed emails for debugging. Use environment variables for Resend API key configuration.",
        "testStrategy": "Test emails send successfully via Resend, verify templates are mobile-responsive, confirm users can opt-out in settings, test weekly report generation and sending, validate failed email logging works correctly",
        "priority": "low",
        "dependencies": [
          "41"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "44",
        "title": "Database Schema Updates for New Features",
        "description": "Create and run database migrations for property status, notifications table, and email preferences",
        "details": "Create Supabase migrations for: 1) Add status column to properties table with enum type (available, sold, reserved) and default 'available', 2) Create notifications table with proper indexes and RLS policies, 3) Add email_notifications_enabled and notification_frequency columns to developers table. Create proper indexes for performance: properties.status, notifications.developer_id+read+created_at. Implement RLS policies ensuring developers can only access their own data. Update TypeScript types to reflect schema changes. Test migrations in development before applying to production.",
        "testStrategy": "Test migrations apply successfully without data loss, verify RLS policies work correctly, confirm indexes improve query performance, validate TypeScript types match database schema, test rollback procedures if needed",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "45",
        "title": "Integration Testing and Quality Assurance",
        "description": "Comprehensive testing of all new features and existing functionality to ensure production readiness",
        "details": "Create comprehensive test suite covering: unit tests for property status management, notifications API, statistics calculations; integration tests for email system, settings updates, dashboard functionality; end-to-end tests for critical user flows (upload → mark as sold → verify ministry endpoints). Test ministry compliance endpoints with various property statuses. Verify TypeScript compilation with 'npm run build'. Test responsive design on mobile/tablet/desktop. Perform security audit of RLS policies and API endpoints. Load test ministry endpoints. Create deployment checklist and verify Vercel deployment succeeds.",
        "testStrategy": "All tests pass including unit, integration, and e2e tests. TypeScript compilation succeeds. Ministry endpoints return correct data excluding sold properties. Security audit passes. Load testing shows acceptable performance. Vercel deployment completes successfully.",
        "priority": "high",
        "dependencies": [
          "36",
          "37",
          "38",
          "39",
          "40",
          "41",
          "42",
          "43",
          "44"
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-07T17:56:28.522Z",
      "taskCount": 10,
      "completedCount": 4,
      "tags": [
        "master"
      ]
    }
  }
}